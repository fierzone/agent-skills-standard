import fs from 'fs-extra';
import yaml from 'js-yaml';
import path from 'path';
import { Agent, SUPPORTED_AGENTS, SUPPORTED_FRAMEWORKS } from '../constants';
import { RegistryMetadata } from '../models/types';
import { ConfigService } from './ConfigService';
import { DetectionService } from './DetectionService';

export interface InitContext {
  frameworkDetection: Record<string, boolean>;
  agentDetection: Record<string, boolean>;
}

export interface InitAnswers {
  framework: string;
  agents: Agent[];
  registry: string;
}

export class InitService {
  private detectionService = new DetectionService();
  private configService = new ConfigService();

  /**
   * Performs environmental discovery for initialization.
   */
  async getInitializationContext(): Promise<InitContext> {
    const [frameworkDetection, agentDetection] = await Promise.all([
      this.detectionService.detectFrameworks(),
      this.detectionService.detectAgents(),
    ]);

    return { frameworkDetection, agentDetection };
  }

  /**
   * Formats detection and registry data into UI-ready choices.
   */
  getPromptChoices(context: InitContext, supportedCategories: string[]) {
    const anyAgentDetected = Object.values(context.agentDetection).some(
      (d) => d,
    );

    const frameworkChoices = SUPPORTED_FRAMEWORKS.map((f) => ({
      name: supportedCategories.includes(f.id)
        ? f.name
        : `${f.name} (Coming Soon)`,
      value: f.id,
    }));

    const agentChoices = SUPPORTED_AGENTS.map((a) => ({
      name: `${a.name} (${a.path}/)`,
      value: a.id,
      checked: anyAgentDetected ? context.agentDetection[a.id] : true,
    }));

    const defaultFramework =
      SUPPORTED_FRAMEWORKS.find((f) => context.frameworkDetection[f.id])?.id ||
      'flutter';

    return { frameworkChoices, agentChoices, defaultFramework };
  }

  /**
   * Orchestrates building and saving the initial configuration.
   */
  async buildAndSaveConfig(
    answers: InitAnswers,
    metadata: Partial<RegistryMetadata>,
    cwd: string = process.cwd(),
  ) {
    const frameworkId = answers.framework;
    const frameworkDef = SUPPORTED_FRAMEWORKS.find((f) => f.id === frameworkId);

    const languages = frameworkDef
      ? await this.detectionService.detectLanguages(frameworkDef)
      : [];

    const config = this.configService.buildInitialConfig(
      frameworkId,
      answers.agents,
      answers.registry,
      metadata,
      languages,
    );

    const projectDeps = await this.detectionService.getProjectDeps();
    this.configService.applyDependencyExclusions(
      config,
      frameworkId,
      projectDeps,
    );

    const commentHeader = `# Auto-detected configuration generated by agent-skills-standard init
#
# Presence in 'skills' list = Active. To disable a skill, remove it from the list.
# 'exclude': IDs of sub-skills to skip during sync (auto-populated with undetected skills).
# 'custom_overrides': IDs of skills to PROTECT. Use this if you have modified a standard 
# skill locally and don't want the CLI to overwrite it.
#
# Run 'ags list-skills' to view all available skills.
#
# TIP: For Jira/Zephyr automation and requirement analysis, manually add:
# skills:
#   quality-engineering: { ref: quality-engineering-v1.0.0 }
#
`;
    const configPath = path.join(cwd, '.skillsrc');
    await fs.writeFile(configPath, commentHeader + yaml.dump(config));
  }
}
